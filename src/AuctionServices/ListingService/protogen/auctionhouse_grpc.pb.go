// Code generated by protoc-gen-go-grpc. DO NOT EDIT.
// versions:
// - protoc-gen-go-grpc v1.2.0
// - protoc             v5.26.0--rc2
// source: auctionhouse.proto

package auction

import (
	context "context"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
)

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
// Requires gRPC-Go v1.32.0 or later.
const _ = grpc.SupportPackageIsVersion7

// ListingServiceClient is the client API for ListingService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type ListingServiceClient interface {
	// Adds a lot to the auction house.
	AddLot(ctx context.Context, in *Lot, opts ...grpc.CallOption) (*Lot, error)
}

type listingServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewListingServiceClient(cc grpc.ClientConnInterface) ListingServiceClient {
	return &listingServiceClient{cc}
}

func (c *listingServiceClient) AddLot(ctx context.Context, in *Lot, opts ...grpc.CallOption) (*Lot, error) {
	out := new(Lot)
	err := c.cc.Invoke(ctx, "/auctionhouse.ListingService/AddLot", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// ListingServiceServer is the server API for ListingService service.
// All implementations must embed UnimplementedListingServiceServer
// for forward compatibility
type ListingServiceServer interface {
	// Adds a lot to the auction house.
	AddLot(context.Context, *Lot) (*Lot, error)
	mustEmbedUnimplementedListingServiceServer()
}

// UnimplementedListingServiceServer must be embedded to have forward compatible implementations.
type UnimplementedListingServiceServer struct {
}

func (UnimplementedListingServiceServer) AddLot(context.Context, *Lot) (*Lot, error) {
	return nil, status.Errorf(codes.Unimplemented, "method AddLot not implemented")
}
func (UnimplementedListingServiceServer) mustEmbedUnimplementedListingServiceServer() {}

// UnsafeListingServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to ListingServiceServer will
// result in compilation errors.
type UnsafeListingServiceServer interface {
	mustEmbedUnimplementedListingServiceServer()
}

func RegisterListingServiceServer(s grpc.ServiceRegistrar, srv ListingServiceServer) {
	s.RegisterService(&ListingService_ServiceDesc, srv)
}

func _ListingService_AddLot_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Lot)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ListingServiceServer).AddLot(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/auctionhouse.ListingService/AddLot",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ListingServiceServer).AddLot(ctx, req.(*Lot))
	}
	return interceptor(ctx, in, info, handler)
}

// ListingService_ServiceDesc is the grpc.ServiceDesc for ListingService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var ListingService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "auctionhouse.ListingService",
	HandlerType: (*ListingServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "AddLot",
			Handler:    _ListingService_AddLot_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "auctionhouse.proto",
}

// ViewingServiceClient is the client API for ViewingService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type ViewingServiceClient interface {
	// Lists all the lots in the auction house.
	ListLots(ctx context.Context, in *Empty, opts ...grpc.CallOption) (ViewingService_ListLotsClient, error)
	// Lists all the lots in the auction house by type
	ListLotsByType(ctx context.Context, in *AuctionTypeRequest, opts ...grpc.CallOption) (ViewingService_ListLotsByTypeClient, error)
	// Lists all the lots in the auction house by status
	ListLotsByStatus(ctx context.Context, in *LotStatusRequest, opts ...grpc.CallOption) (ViewingService_ListLotsByStatusClient, error)
	// Lists all the lots in the auction house by user
	ListLotsByUser(ctx context.Context, in *User, opts ...grpc.CallOption) (ViewingService_ListLotsByUserClient, error)
	// get a constant stream of one lot
	GetLot(ctx context.Context, in *Lot, opts ...grpc.CallOption) (ViewingService_GetLotClient, error)
}

type viewingServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewViewingServiceClient(cc grpc.ClientConnInterface) ViewingServiceClient {
	return &viewingServiceClient{cc}
}

func (c *viewingServiceClient) ListLots(ctx context.Context, in *Empty, opts ...grpc.CallOption) (ViewingService_ListLotsClient, error) {
	stream, err := c.cc.NewStream(ctx, &ViewingService_ServiceDesc.Streams[0], "/auctionhouse.ViewingService/ListLots", opts...)
	if err != nil {
		return nil, err
	}
	x := &viewingServiceListLotsClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type ViewingService_ListLotsClient interface {
	Recv() (*Lot, error)
	grpc.ClientStream
}

type viewingServiceListLotsClient struct {
	grpc.ClientStream
}

func (x *viewingServiceListLotsClient) Recv() (*Lot, error) {
	m := new(Lot)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *viewingServiceClient) ListLotsByType(ctx context.Context, in *AuctionTypeRequest, opts ...grpc.CallOption) (ViewingService_ListLotsByTypeClient, error) {
	stream, err := c.cc.NewStream(ctx, &ViewingService_ServiceDesc.Streams[1], "/auctionhouse.ViewingService/ListLotsByType", opts...)
	if err != nil {
		return nil, err
	}
	x := &viewingServiceListLotsByTypeClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type ViewingService_ListLotsByTypeClient interface {
	Recv() (*Lot, error)
	grpc.ClientStream
}

type viewingServiceListLotsByTypeClient struct {
	grpc.ClientStream
}

func (x *viewingServiceListLotsByTypeClient) Recv() (*Lot, error) {
	m := new(Lot)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *viewingServiceClient) ListLotsByStatus(ctx context.Context, in *LotStatusRequest, opts ...grpc.CallOption) (ViewingService_ListLotsByStatusClient, error) {
	stream, err := c.cc.NewStream(ctx, &ViewingService_ServiceDesc.Streams[2], "/auctionhouse.ViewingService/ListLotsByStatus", opts...)
	if err != nil {
		return nil, err
	}
	x := &viewingServiceListLotsByStatusClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type ViewingService_ListLotsByStatusClient interface {
	Recv() (*Lot, error)
	grpc.ClientStream
}

type viewingServiceListLotsByStatusClient struct {
	grpc.ClientStream
}

func (x *viewingServiceListLotsByStatusClient) Recv() (*Lot, error) {
	m := new(Lot)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *viewingServiceClient) ListLotsByUser(ctx context.Context, in *User, opts ...grpc.CallOption) (ViewingService_ListLotsByUserClient, error) {
	stream, err := c.cc.NewStream(ctx, &ViewingService_ServiceDesc.Streams[3], "/auctionhouse.ViewingService/ListLotsByUser", opts...)
	if err != nil {
		return nil, err
	}
	x := &viewingServiceListLotsByUserClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type ViewingService_ListLotsByUserClient interface {
	Recv() (*Lot, error)
	grpc.ClientStream
}

type viewingServiceListLotsByUserClient struct {
	grpc.ClientStream
}

func (x *viewingServiceListLotsByUserClient) Recv() (*Lot, error) {
	m := new(Lot)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *viewingServiceClient) GetLot(ctx context.Context, in *Lot, opts ...grpc.CallOption) (ViewingService_GetLotClient, error) {
	stream, err := c.cc.NewStream(ctx, &ViewingService_ServiceDesc.Streams[4], "/auctionhouse.ViewingService/GetLot", opts...)
	if err != nil {
		return nil, err
	}
	x := &viewingServiceGetLotClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type ViewingService_GetLotClient interface {
	Recv() (*Lot, error)
	grpc.ClientStream
}

type viewingServiceGetLotClient struct {
	grpc.ClientStream
}

func (x *viewingServiceGetLotClient) Recv() (*Lot, error) {
	m := new(Lot)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

// ViewingServiceServer is the server API for ViewingService service.
// All implementations must embed UnimplementedViewingServiceServer
// for forward compatibility
type ViewingServiceServer interface {
	// Lists all the lots in the auction house.
	ListLots(*Empty, ViewingService_ListLotsServer) error
	// Lists all the lots in the auction house by type
	ListLotsByType(*AuctionTypeRequest, ViewingService_ListLotsByTypeServer) error
	// Lists all the lots in the auction house by status
	ListLotsByStatus(*LotStatusRequest, ViewingService_ListLotsByStatusServer) error
	// Lists all the lots in the auction house by user
	ListLotsByUser(*User, ViewingService_ListLotsByUserServer) error
	// get a constant stream of one lot
	GetLot(*Lot, ViewingService_GetLotServer) error
	mustEmbedUnimplementedViewingServiceServer()
}

// UnimplementedViewingServiceServer must be embedded to have forward compatible implementations.
type UnimplementedViewingServiceServer struct {
}

func (UnimplementedViewingServiceServer) ListLots(*Empty, ViewingService_ListLotsServer) error {
	return status.Errorf(codes.Unimplemented, "method ListLots not implemented")
}
func (UnimplementedViewingServiceServer) ListLotsByType(*AuctionTypeRequest, ViewingService_ListLotsByTypeServer) error {
	return status.Errorf(codes.Unimplemented, "method ListLotsByType not implemented")
}
func (UnimplementedViewingServiceServer) ListLotsByStatus(*LotStatusRequest, ViewingService_ListLotsByStatusServer) error {
	return status.Errorf(codes.Unimplemented, "method ListLotsByStatus not implemented")
}
func (UnimplementedViewingServiceServer) ListLotsByUser(*User, ViewingService_ListLotsByUserServer) error {
	return status.Errorf(codes.Unimplemented, "method ListLotsByUser not implemented")
}
func (UnimplementedViewingServiceServer) GetLot(*Lot, ViewingService_GetLotServer) error {
	return status.Errorf(codes.Unimplemented, "method GetLot not implemented")
}
func (UnimplementedViewingServiceServer) mustEmbedUnimplementedViewingServiceServer() {}

// UnsafeViewingServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to ViewingServiceServer will
// result in compilation errors.
type UnsafeViewingServiceServer interface {
	mustEmbedUnimplementedViewingServiceServer()
}

func RegisterViewingServiceServer(s grpc.ServiceRegistrar, srv ViewingServiceServer) {
	s.RegisterService(&ViewingService_ServiceDesc, srv)
}

func _ViewingService_ListLots_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(Empty)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(ViewingServiceServer).ListLots(m, &viewingServiceListLotsServer{stream})
}

type ViewingService_ListLotsServer interface {
	Send(*Lot) error
	grpc.ServerStream
}

type viewingServiceListLotsServer struct {
	grpc.ServerStream
}

func (x *viewingServiceListLotsServer) Send(m *Lot) error {
	return x.ServerStream.SendMsg(m)
}

func _ViewingService_ListLotsByType_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(AuctionTypeRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(ViewingServiceServer).ListLotsByType(m, &viewingServiceListLotsByTypeServer{stream})
}

type ViewingService_ListLotsByTypeServer interface {
	Send(*Lot) error
	grpc.ServerStream
}

type viewingServiceListLotsByTypeServer struct {
	grpc.ServerStream
}

func (x *viewingServiceListLotsByTypeServer) Send(m *Lot) error {
	return x.ServerStream.SendMsg(m)
}

func _ViewingService_ListLotsByStatus_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(LotStatusRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(ViewingServiceServer).ListLotsByStatus(m, &viewingServiceListLotsByStatusServer{stream})
}

type ViewingService_ListLotsByStatusServer interface {
	Send(*Lot) error
	grpc.ServerStream
}

type viewingServiceListLotsByStatusServer struct {
	grpc.ServerStream
}

func (x *viewingServiceListLotsByStatusServer) Send(m *Lot) error {
	return x.ServerStream.SendMsg(m)
}

func _ViewingService_ListLotsByUser_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(User)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(ViewingServiceServer).ListLotsByUser(m, &viewingServiceListLotsByUserServer{stream})
}

type ViewingService_ListLotsByUserServer interface {
	Send(*Lot) error
	grpc.ServerStream
}

type viewingServiceListLotsByUserServer struct {
	grpc.ServerStream
}

func (x *viewingServiceListLotsByUserServer) Send(m *Lot) error {
	return x.ServerStream.SendMsg(m)
}

func _ViewingService_GetLot_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(Lot)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(ViewingServiceServer).GetLot(m, &viewingServiceGetLotServer{stream})
}

type ViewingService_GetLotServer interface {
	Send(*Lot) error
	grpc.ServerStream
}

type viewingServiceGetLotServer struct {
	grpc.ServerStream
}

func (x *viewingServiceGetLotServer) Send(m *Lot) error {
	return x.ServerStream.SendMsg(m)
}

// ViewingService_ServiceDesc is the grpc.ServiceDesc for ViewingService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var ViewingService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "auctionhouse.ViewingService",
	HandlerType: (*ViewingServiceServer)(nil),
	Methods:     []grpc.MethodDesc{},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "ListLots",
			Handler:       _ViewingService_ListLots_Handler,
			ServerStreams: true,
		},
		{
			StreamName:    "ListLotsByType",
			Handler:       _ViewingService_ListLotsByType_Handler,
			ServerStreams: true,
		},
		{
			StreamName:    "ListLotsByStatus",
			Handler:       _ViewingService_ListLotsByStatus_Handler,
			ServerStreams: true,
		},
		{
			StreamName:    "ListLotsByUser",
			Handler:       _ViewingService_ListLotsByUser_Handler,
			ServerStreams: true,
		},
		{
			StreamName:    "GetLot",
			Handler:       _ViewingService_GetLot_Handler,
			ServerStreams: true,
		},
	},
	Metadata: "auctionhouse.proto",
}

// BidSubmitServiceClient is the client API for BidSubmitService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type BidSubmitServiceClient interface {
	// Bids on a lot.
	Bid(ctx context.Context, in *BidRequest, opts ...grpc.CallOption) (*Lot, error)
}

type bidSubmitServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewBidSubmitServiceClient(cc grpc.ClientConnInterface) BidSubmitServiceClient {
	return &bidSubmitServiceClient{cc}
}

func (c *bidSubmitServiceClient) Bid(ctx context.Context, in *BidRequest, opts ...grpc.CallOption) (*Lot, error) {
	out := new(Lot)
	err := c.cc.Invoke(ctx, "/auctionhouse.BidSubmitService/Bid", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// BidSubmitServiceServer is the server API for BidSubmitService service.
// All implementations must embed UnimplementedBidSubmitServiceServer
// for forward compatibility
type BidSubmitServiceServer interface {
	// Bids on a lot.
	Bid(context.Context, *BidRequest) (*Lot, error)
	mustEmbedUnimplementedBidSubmitServiceServer()
}

// UnimplementedBidSubmitServiceServer must be embedded to have forward compatible implementations.
type UnimplementedBidSubmitServiceServer struct {
}

func (UnimplementedBidSubmitServiceServer) Bid(context.Context, *BidRequest) (*Lot, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Bid not implemented")
}
func (UnimplementedBidSubmitServiceServer) mustEmbedUnimplementedBidSubmitServiceServer() {}

// UnsafeBidSubmitServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to BidSubmitServiceServer will
// result in compilation errors.
type UnsafeBidSubmitServiceServer interface {
	mustEmbedUnimplementedBidSubmitServiceServer()
}

func RegisterBidSubmitServiceServer(s grpc.ServiceRegistrar, srv BidSubmitServiceServer) {
	s.RegisterService(&BidSubmitService_ServiceDesc, srv)
}

func _BidSubmitService_Bid_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(BidRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(BidSubmitServiceServer).Bid(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/auctionhouse.BidSubmitService/Bid",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(BidSubmitServiceServer).Bid(ctx, req.(*BidRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// BidSubmitService_ServiceDesc is the grpc.ServiceDesc for BidSubmitService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var BidSubmitService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "auctionhouse.BidSubmitService",
	HandlerType: (*BidSubmitServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "Bid",
			Handler:    _BidSubmitService_Bid_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "auctionhouse.proto",
}

// BidViewingServiceClient is the client API for BidViewingService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type BidViewingServiceClient interface {
}

type bidViewingServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewBidViewingServiceClient(cc grpc.ClientConnInterface) BidViewingServiceClient {
	return &bidViewingServiceClient{cc}
}

// BidViewingServiceServer is the server API for BidViewingService service.
// All implementations must embed UnimplementedBidViewingServiceServer
// for forward compatibility
type BidViewingServiceServer interface {
	mustEmbedUnimplementedBidViewingServiceServer()
}

// UnimplementedBidViewingServiceServer must be embedded to have forward compatible implementations.
type UnimplementedBidViewingServiceServer struct {
}

func (UnimplementedBidViewingServiceServer) mustEmbedUnimplementedBidViewingServiceServer() {}

// UnsafeBidViewingServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to BidViewingServiceServer will
// result in compilation errors.
type UnsafeBidViewingServiceServer interface {
	mustEmbedUnimplementedBidViewingServiceServer()
}

func RegisterBidViewingServiceServer(s grpc.ServiceRegistrar, srv BidViewingServiceServer) {
	s.RegisterService(&BidViewingService_ServiceDesc, srv)
}

// BidViewingService_ServiceDesc is the grpc.ServiceDesc for BidViewingService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var BidViewingService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "auctionhouse.BidViewingService",
	HandlerType: (*BidViewingServiceServer)(nil),
	Methods:     []grpc.MethodDesc{},
	Streams:     []grpc.StreamDesc{},
	Metadata:    "auctionhouse.proto",
}
